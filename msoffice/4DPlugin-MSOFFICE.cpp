/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-MSOFFICE.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : MSOFFICE
 #	author : miyako
 #	2023/12/11
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-MSOFFICE.h"

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
        switch(selector)
        {
#if USE_OPC
            case kInitPlugin :
            case kServerInitPlugin :
                opcInitLibrary();
                break;
                
            case kDeinitPlugin :
            case kServerDeinitPlugin :
                opcFreeLibrary();
                break;
#endif
			// --- MSOFFICE
            
			case 1 :
#if USE_OPENXLSX
				Write_to_spreadsheet(params);
#endif
#if USE_XLNT
                Write_to_spreadsheet_xlnt(params);
#endif
				break;
			case 2 :
#if USE_OPENXLSX
				Read_from_spreadsheet(params);
#endif
#if USE_XLNT
                Read_to_spreadsheet_xlnt(params);
#endif
                break;
                
            case 3 :
                Verify_office_document(params);
                break;
                
            case 4 :
                Decode_office_document(params);
                break;
                
            case 5 :
                Encode_office_document(params);
                break;

        }

	}
	catch(...)
	{

	}
}

#pragma mark path utilities

#if VERSIONWIN
static void generateUuid(std::wstring &uuidstr)
{
    RPC_WSTR str;
    UUID uuid;

    if (UuidCreate(&uuid) == RPC_S_OK) {
        if (UuidToString(&uuid, &str) == RPC_S_OK) {
            size_t len = wcslen((const wchar_t *)str);
            std::vector<wchar_t>buf(len);
            memcpy(&buf[0], str, len * sizeof(wchar_t));
            _wcsupr((wchar_t *)&buf[0]);
            uuidstr = std::wstring((const wchar_t *)&buf[0], len);
            RpcStringFree(&str);
        }
    }
}
#endif

static void temporary_file_path(CUTF8String& path) {
    
#if VERSIONWIN

    std::wstring path_u16 = std::filesystem::temp_directory_path().wstring();

    /*
    wchar_t fDrive[_MAX_DRIVE], fDir[_MAX_DIR], fName[_MAX_FNAME], fExt[_MAX_EXT];
    std::vector<wchar_t>_buf(_MAX_DRIVE + _MAX_DIR + _MAX_FNAME + _MAX_EXT);
    GetTempPath(_buf.size(), (LPWSTR)&_buf[0]);
    std::wstring path_u16 = (LPWSTR)&_buf[0];
    */

    std::wstring uuid;
    generateUuid(uuid);

    path_u16 += uuid;
    path_u16 += L".zip";
    
    C_TEXT t;
    t.setUTF16String((const PA_Unichar *)path_u16.c_str(), path_u16.length());
    t.copyUTF8String(&path);

    std::replace(path.begin(), path.end(), '\\', '/');

#else
    NSURL *url = nil;
    
    NSArray *URLs = [[NSFileManager defaultManager]
                     URLsForDirectory:NSDesktopDirectory
                     inDomains:NSUserDomainMask];
    
    if(URLs && [URLs count])
    {
        url = [[NSFileManager defaultManager]
               URLForDirectory:NSItemReplacementDirectory
               inDomain:NSUserDomainMask
               appropriateForURL:[URLs objectAtIndex:0]
               create:YES
               error:nil];
    }
    
    if(url != NULL) {
        
        NSString *str = (NSString *)CFURLCopyFileSystemPath((CFURLRef)url, kCFURLPOSIXPathStyle);
        if(str != NULL) {
            path = (const uint8_t *)[str UTF8String];
            [str release];
        }
    }
#endif
}

static void copy_document_native(C_TEXT& infilename, C_TEXT& outfilename) {

    PA_Variable params[3];
    params[0] = PA_CreateVariable(eVK_Unistring);
    params[1] = PA_CreateVariable(eVK_Unistring);
    params[2] = PA_CreateVariable(eVK_Undefined);

    PA_Unistring ifilepath =
    PA_CreateUnistring((PA_Unichar *)infilename.getUTF16StringPtr());
    PA_Unistring ofilepath =
    PA_CreateUnistring((PA_Unichar *)outfilename.getUTF16StringPtr());

    PA_SetStringVariable(&params[0], &ifilepath);
    PA_SetStringVariable(&params[1], &ofilepath);
    PA_SetOperationVariable(&params[2], '*');

    PA_ExecuteCommandByID(541, params, 3);

    PA_ClearVariable(&params[0]);
    PA_ClearVariable(&params[1]);
    PA_ClearVariable(&params[2]);
}

#if VERSIONMAC
static bool create_folder(std::string& folderPath) {
    
    bool success = false;
    
    NSString *path = (NSString *)CFStringCreateWithFileSystemRepresentation(kCFAllocatorDefault, folderPath.c_str());
    NSFileManager *fm = [[NSFileManager alloc]init];
    success = [fm createDirectoryAtPath:path
            withIntermediateDirectories:YES
                             attributes:nil
                                  error:NULL];
    [path release];
    [fm release];
    
    return success;
}
#endif

#if VERSIONWIN
static bool create_folder(std::wstring& folderPath) {
    
    return SHCreateDirectory(NULL, (PCWSTR)folderPath.c_str());
}
#endif

static void create_parent_folder(CUTF8String& outfilename) {
    
#if VERSIONMAC
    NSString *filePath = (NSString *)CFStringCreateWithFileSystemRepresentation(kCFAllocatorDefault, (const char *)outfilename.c_str());
    std::string folderPath = std::string([[filePath stringByDeletingLastPathComponent]fileSystemRepresentation]);
    create_folder(folderPath);
    [filePath release];
#else
    CUTF16String u16;
    C_TEXT t;
    t.setUTF8String((const uint8_t *)outfilename.c_str(), outfilename.length());
    t.copyUTF16String(&u16);
    
    std::wstring filepath = (const wchar_t *)u16.c_str();
    
    wchar_t fDrive[_MAX_DRIVE],
    fDir[_MAX_DIR],
    fName[_MAX_FNAME],
    fExt[_MAX_EXT];
    _wsplitpath_s(filepath.c_str(), fDrive, fDir, fName, fExt);
    std::wstring folderPath = fDrive;
    folderPath += fDir;
    create_folder(folderPath);
#endif
}

#pragma mark OpenXLSX

#if USE_OPENXLSX
static void OpenXLSX_getCellValue(OpenXLSX::XLCell c, PA_ObjectRef values) {
    
    PA_ObjectRef cellInfo = PA_CreateObject();
    
    std::string columnString = c.cellReference().address();
    
    OpenXLSX::XLValueType type = c.value().type();
    
    switch (type) {
        case OpenXLSX::XLValueType::Empty:
            ob_set_s(cellInfo, L"data_type", "empty");
            ob_set_s(cellInfo, L"stringValue", "");
            break;
        case OpenXLSX::XLValueType::Boolean:
            ob_set_s(cellInfo, L"data_type", "boolean");
            ob_set_b(cellInfo, L"value", c.value());
            break;
        case OpenXLSX::XLValueType::Integer:
            ob_set_s(cellInfo, L"data_type", "number");
            ob_set_n(cellInfo, L"value", (int64_t)c.value());
            break;
        case OpenXLSX::XLValueType::Float:
            ob_set_s(cellInfo, L"data_type", "number");
            ob_set_n(cellInfo, L"value", (double)c.value());
            break;
        case OpenXLSX::XLValueType::Error:
            ob_set_s(cellInfo, L"data_type", "error");
            ob_set_s(cellInfo, L"stringValue", c.value().get<std::string>().c_str());
            break;
        case OpenXLSX::XLValueType::String:
            ob_set_s(cellInfo, L"data_type", "string");
            ob_set_s(cellInfo, L"stringValue", c.value().get<std::string>().c_str());
            break;
        default:
            break;
    }

    ob_set_o(values, columnString.c_str(), cellInfo);
}
#endif

#pragma mark xlnt

#if USE_XLNT
static void xlnt_getCellValue(xlnt::cell c, PA_ObjectRef values) {

    char buf[16];
    PA_ObjectRef cellInfo = PA_CreateObject();
    std::string columnString = c.column().column_string();
    snprintf(buf, 15, "%d", c.row());
    columnString += (const char *)&buf[0];

    if(c.has_comment()) {
        PA_ObjectRef comment = PA_CreateObject();
        ob_set_s(comment, L"plain_text", c.comment().plain_text().c_str());
        ob_set_s(comment, L"author", c.comment().author().c_str());
        ob_set_o(cellInfo, L"comment", comment);
    }
    
    if(c.has_value()) {
        switch (c.data_type()) {
            case xlnt::cell_type::empty:
                ob_set_s(cellInfo, L"data_type", "empty");
                ob_set_s(cellInfo, L"stringValue", "");
                break;
            case xlnt::cell_type::error:
                ob_set_s(cellInfo, L"data_type", "error");
                ob_set_s(cellInfo, L"stringValue", c.error().c_str());
                break;
            case xlnt::cell_type::date:
                ob_set_s(cellInfo, L"data_type", "date");
                ob_set_n(cellInfo, L"value", c.value<xlnt::date>().to_number(c.base_date()));
                break;
            case xlnt::cell_type::number:
                ob_set_s(cellInfo, L"data_type", "number");
                ob_set_n(cellInfo, L"value", c.value<double>());
                break;
            case xlnt::cell_type::boolean:
                ob_set_s(cellInfo, L"data_type", "boolean");
                ob_set_b(cellInfo, L"value", c.value<bool>());
                break;
            case xlnt::cell_type::shared_string:
                ob_set_s(cellInfo, L"data_type", "shared_string");
                ob_set_s(cellInfo, L"stringValue", c.to_string().c_str());
                break;
            case xlnt::cell_type::inline_string:
                ob_set_s(cellInfo, L"data_type", "inline_string");
                ob_set_s(cellInfo, L"stringValue", c.to_string().c_str());
                break;
            case xlnt::cell_type::formula_string:
                ob_set_s(cellInfo, L"data_type", "formula_string");
                ob_set_s(cellInfo, L"stringValue", c.formula().c_str());
                break;
        }
    }
    
    ob_set_o(values, columnString.c_str(), cellInfo);
}

static xlnt::workbook *open_workbook(CUTF8String& infilename_u8, C_TEXT& password) {
    
    xlnt::workbook *wb = new xlnt::workbook;
    
    try {
        if(password.getUTF16Length()) {
            CUTF8String password_u8;
            password.copyUTF8String(&password_u8);
            wb->load(std::string((const char *)infilename_u8.c_str()),
                     std::string((const char *)password_u8.c_str()));
        }else{
            wb->load(std::string((const char *)infilename_u8.c_str()));
        }
    }
    catch (std::exception& e) {
        std::cout << e.what() << std::endl;
        delete wb;
        return NULL;
    }
    
    return wb;
}

static void close_workbook(xlnt::workbook *wb, CUTF8String& outfilename_u8, C_TEXT& password) {
    
    try {
        if(password.getUTF16Length()) {
            CUTF8String password_u8;
            password.copyUTF8String(&password_u8);
            wb->save(std::string((const char *)outfilename_u8.c_str()),
                     std::string((const char *)password_u8.c_str()));
        }else{
            wb->save(std::string((const char *)outfilename_u8.c_str()));
        }
    }
    catch (std::exception& e) {
        std::cout << e.what() << std::endl;
    }
}

static void Write_to_spreadsheet_xlnt(PA_PluginParameters params) {
    
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    PA_ObjectRef status = PA_CreateObject();
    ob_set_b(status, L"success", false);
    
    C_TEXT infilename;
    infilename.fromParamAtIndex(pParams, 1);
    CUTF8String infilename_u8;
    infilename.copyPath(&infilename_u8);
    
    C_TEXT outfilename;
    outfilename.fromParamAtIndex(pParams, 2);
    CUTF8String outfilename_u8;
    outfilename.copyPath(&outfilename_u8);
    
    if(infilename_u8 != outfilename_u8) {
        
        PA_ObjectRef references = PA_GetObjectParameter(params, 3);
        
        if(references != NULL) {
            
            C_TEXT password;
            password.fromParamAtIndex(pParams, 4);
                
            xlnt::workbook *wb = open_workbook(infilename_u8, password);
            
            if(wb != NULL) {
            
                Json::Value value;
                
                bool parse = parseReferencesObject(references, &value);
                
                if(parse) {
                    for(Json::Value::const_iterator it = value.begin() ; it != value.end() ; it++)
                    {
                        std::string sheet_title = (std::string((char *)it.name().c_str()));
                        
                        const xlnt::worksheet ws = wb->sheet_by_title(sheet_title);
                        if(ws != NULL) {
                            if(it->isObject()) {
                                for(Json::Value::const_iterator itt = it->begin() ; itt != it->end() ; itt++) {
                                    JSONCPP_STRING cellRef = itt.name();
                                    xlnt::cell c = ws.cell(cellRef);
                                    std::string stringValue = itt->asString();
                                    long long int int64Value;

                                    if(itt->isString())
                                    {
                                        c.value(stringValue);
                                        continue;
                                    }
                                    if(itt->isBool())
                                    {
                                        c.value(itt->asBool());
                                        continue;
                                    }
                                    if(itt->isNull())
                                    {
                                        c.clear_value();
                                        continue;
                                    }
                                    if(itt->isInt64())
                                    {
                                        c.value(itt->asInt64());
                                        continue;
                                    }
                                    if(itt->isInt())
                                    {
                                        c.value(itt->asInt());
                                        continue;
                                    }
                                    if(itt->isDouble())
                                    {
                                        c.value(itt->asDouble());
                                        continue;
                                    }
                                }
                            }
                        }
                    }
                                
                    CUTF8String temp;
                    temporary_file_path(temp);
                    
                    close_workbook(wb, temp, password);
                    
                    create_parent_folder(outfilename_u8);
                    
                    copy_document_native(infilename, outfilename);
                                
                    copy_macro_parts(temp, outfilename_u8);
                    
                    close_workbook(wb, outfilename_u8, password);

                    delete wb;
                    
                    copy_macro_parts(infilename_u8, outfilename_u8);

                    ob_set_b(status, L"success", true);
                }
            }
        }
    }
 
    PA_ReturnObject(params, status);
}

Read_to_spreadsheet_xlnt(PA_PluginParameters params) {
    
}
#endif

static bool parseReferencesObject(PA_ObjectRef references, Json::Value *value) {
    
    if(references == NULL) return false;
    
    PA_Variable v = PA_CreateVariable(eVK_Object);
    PA_SetObjectVariable(&v, PA_DuplicateObject(references));
    PA_Unistring u16 = PA_JsonStringify(v, false);
    PA_ClearVariable(&v);
    
    C_TEXT t;
    t.setUTF16String(&u16);
    CUTF8String u8;
    t.copyUTF8String(&u8);
    
    Json::CharReaderBuilder builder;
    builder["collectComments"] = false;

    Json::String errors;
    
    Json::CharReader *reader = builder.newCharReader();
    
    bool parse = reader->parse((const char *)u8.c_str(),
                               (const char *)u8.c_str() + u8.size(),
                               value,
                               &errors);
    
    delete reader;
    
    return parse;
}

#pragma mark -

#if USE_OPENXLSX
static void Write_to_spreadsheet(PA_PluginParameters params) {

    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    PA_ObjectRef status = PA_CreateObject();
    ob_set_b(status, L"success", false);
    
    C_TEXT infilename;
    infilename.fromParamAtIndex(pParams, 1);
    CUTF8String infilename_u8;
    infilename.copyPath(&infilename_u8);
    
    C_TEXT outfilename;
    outfilename.fromParamAtIndex(pParams, 2);
    CUTF8String outfilename_u8;
    outfilename.copyPath(&outfilename_u8);
    
    if(infilename_u8 != outfilename_u8) {
     
        PA_ObjectRef references = PA_GetObjectParameter(params, 3);
        
        if(references != NULL) {
            
            OpenXLSX::XLDocument doc;
            
            try {
                
                doc.open(std::string((const char *)infilename_u8.c_str()));
                                
                auto wb = doc.workbook();
                
                Json::Value value;
                
                bool parse = parseReferencesObject(references, &value);
                
                if(parse) {
                    for(Json::Value::const_iterator it = value.begin() ; it != value.end() ; it++) {
                        std::string sheet_title = (std::string((char *)it.name().c_str()));
                        if(wb.sheetExists(sheet_title)) {
                            OpenXLSX::XLWorksheet ws = wb.worksheet(sheet_title);
                            if(it->isObject()) {
                                for(Json::Value::const_iterator itt = it->begin() ; itt != it->end() ; itt++) {
                                    JSONCPP_STRING cellRef = itt.name();
                                    OpenXLSX::XLCell c = ws.cell(cellRef);

                                    if(itt->isString())
                                    {
                                        c.value() = itt->asString();
                                        continue;
                                    }
                                    if(itt->isBool())
                                    {
                                        c.value() = itt->asBool();
                                        continue;
                                    }
                                    if(itt->isNull())
                                    {
                                        c.value() = NULL;
                                        continue;
                                    }
                                    if(itt->isInt64())
                                    {
                                        c.value() = itt->asInt64();
                                        continue;
                                    }
                                    if(itt->isInt())
                                    {
                                        c.value() = itt->asInt();
                                        continue;
                                    }
                                    if(itt->isDouble())
                                    {
                                        c.value() = itt->asDouble();
                                        continue;
                                    }
                                }
                            }
                        }
                    }
                 
                    CUTF8String temp;
                    temporary_file_path(temp);
                  
                    ob_set_s(status, L"temporaryFilePath", (const char *)temp.c_str());

                    doc.saveAs(std::string((const char *)temp.c_str()));

                    doc.close();
                    
                    create_parent_folder(outfilename_u8);
                    
                    copy_document_native(infilename, outfilename);
                    
                    copy_macro_parts(temp, outfilename_u8);
                              
                    ob_set_b(status, L"success", true);
                }
                
            } catch (std::exception& e) {
                ob_set_s(status, L"error", e.what());
            }
        }

    }

    PA_ReturnObject(params, status);
}

static void Read_from_spreadsheet(PA_PluginParameters params) {

    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    PA_ObjectRef status = PA_CreateObject();
    ob_set_b(status, L"success", false);
 
    C_TEXT filename;
    filename.fromParamAtIndex(pParams, 1);
    CUTF8String filename_u8;
    filename.copyPath(&filename_u8);
    
    PA_ObjectRef references = PA_GetObjectParameter(params, 2);
        
    OpenXLSX::XLDocument doc;
    
    try {
        
        doc.open(std::string((const char *)filename_u8.c_str()));
        ob_set_b(status, L"success", true);
        
        auto wb = doc.workbook();
        
        PA_ObjectRef core_property = PA_CreateObject();
        
        std::string title = doc.property(OpenXLSX::XLProperty::Title);
        ob_set_s(core_property, L"title", title.c_str());
        
        std::string subject = doc.property(OpenXLSX::XLProperty::Subject);
        ob_set_s(core_property, L"subject", subject.c_str());
        
        std::string creator = doc.property(OpenXLSX::XLProperty::Creator);
        ob_set_s(core_property, L"creator", creator.c_str());
        
        std::string keywords = doc.property(OpenXLSX::XLProperty::Keywords);
        ob_set_s(core_property, L"keywords", keywords.c_str());
        
        std::string description = doc.property(OpenXLSX::XLProperty::Description);
        ob_set_s(core_property, L"description", description.c_str());
        
        std::string category = doc.property(OpenXLSX::XLProperty::Category);
        ob_set_s(core_property, L"category", category.c_str());

        std::string last_modified_by = doc.property(OpenXLSX::XLProperty::LastModifiedBy);
        ob_set_s(core_property, L"last_modified_by", last_modified_by.c_str());
        
        std::string created = doc.property(OpenXLSX::XLProperty::CreationDate);
        ob_set_s(core_property, L"created", created.c_str());

        std::string modified = doc.property(OpenXLSX::XLProperty::ModificationDate);
        ob_set_s(core_property, L"modified", modified.c_str());
        
        std::string last_printed = doc.property(OpenXLSX::XLProperty::LastPrinted);
        ob_set_s(core_property, L"last_printed", last_printed.c_str());
        
        std::string version = doc.property(OpenXLSX::XLProperty::AppVersion);
        ob_set_s(core_property, L"version", version.c_str());
        
        ob_set_o(status, L"core_property", core_property);
        
        PA_ObjectRef values = PA_CreateObject();
        
        if(references != NULL) {
            
            Json::Value value;
            
            bool parse = parseReferencesObject(references, &value);

            if(parse)
            {
                for(Json::Value::const_iterator it = value.begin() ; it != value.end() ; it++)
                {
                    
                    std::string sheet_title = (std::string((char *)it.name().c_str()));
                    
                    if(wb.sheetExists(sheet_title)) {
                        
                        PA_ObjectRef sheetObj = PA_CreateObject();
                        
                        OpenXLSX::XLWorksheet ws = wb.worksheet(sheet_title);
                        
                        if(it->isArray()) {
                            for(Json::Value::const_iterator itt = it->begin() ; itt != it->end() ; itt++)
                            {
                                if(itt->isString()) {
                                    Json::String cellRef = itt->asString();
                                    OpenXLSX::XLCell c = ws.cell(cellRef);
                                    OpenXLSX_getCellValue(c, sheetObj);
                                }
                            }
                        }
                        ob_set_o(values, (const char *)sheet_title.c_str(), sheetObj);
                    }
                }
            }
        }

        PA_CollectionRef titles = PA_CreateCollection();
        
        std::vector<std::string> worksheets = wb.worksheetNames();
        
        for (std::vector<std::string>::iterator it = worksheets.begin(); it != worksheets.end(); it++)
        {
            std::string sheet_title = *it;
            
            PA_Variable v = PA_CreateVariable(eVK_Unistring);
            C_TEXT t;
            t.setUTF8String((const uint8_t *)sheet_title.c_str(), (uint32_t)sheet_title.length());
            CUTF16String u16;
            t.copyUTF16String(&u16);
            PA_Unistring u = PA_CreateUnistring((PA_Unichar *)u16.c_str());
            PA_SetStringVariable(&v, &u);
            PA_SetCollectionElement(titles, PA_GetCollectionLength(titles), v);
            PA_ClearVariable(&v);

            if(references == NULL) {

                OpenXLSX::XLWorksheet ws = wb.worksheet(sheet_title);
                
                PA_ObjectRef sheetObj = PA_CreateObject();
                
                for(OpenXLSX::XLRowIterator itt = ws.rows().begin() ; itt !=  ws.rows().end() ; itt++)
                {
                    OpenXLSX::XLRow row = *itt;
                    for(OpenXLSX::XLRowDataIterator ittt = row.cells().begin() ; ittt !=  row.cells().end() ; ittt++)
                    {
                        OpenXLSX::XLCell c = *ittt;
                        
                        OpenXLSX_getCellValue(c, sheetObj);
                    }
                }
                ob_set_o(values, (const char *)sheet_title.c_str(), sheetObj);
            }else{
                
            }
        }
        
        ob_set_c(status, L"sheets", titles);
        ob_set_o(status, L"values", values);

        doc.close();
        
    } catch (std::exception& e) {
    
    }
        
    PA_ReturnObject(params, status);
}
#endif

#pragma mark -

static void copy_macro_parts(CUTF8String& infilename_u8, CUTF8String& outfilename_u8) {
    
    opcContainer *source = opcContainerOpen(_X(infilename_u8.c_str()),
                                            OPC_OPEN_READ_ONLY, NULL, NULL);
    if(source) {
        opcContainer *target = opcContainerOpen(_X(outfilename_u8.c_str()),
                                                OPC_OPEN_READ_WRITE, NULL, NULL);
        if(target) {
            
            for(opcPart part=opcPartGetFirst(source);
                OPC_PART_INVALID!=part;
                part=opcPartGetNext(source, part)) {
                
                opc_ofs_t size = opcPartGetSize(source, part);
                const xmlChar *type = opcPartGetType(source, part);
                
                std::string typeString = (const char *)type;
                std::string partString = (const char *)part;
                
                if(  false
                     || (typeString == "application/vnd.ms-office.vbaProject")
                     || (typeString == "application/vnd.ms-office.activeX")
                     || (typeString == "application/vnd.ms-office.activeX+xml")
//                   || (typeString == "application/vnd.ms-excel.sheet.macroEnabled.main+xml")
//                   || (typeString == "application/vnd.openxmlformats-officedocument.theme+xml")
//                   || (typeString == "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetMetadata+xml")
//                   || (typeString == "application/vnd.openxmlformats-officedocument.customXmlProperties+xml")
//                   || (typeString == "application/vnd.openxmlformats-officedocument.extended-properties+xml")
//                   || (typeString == "application/vnd.openxmlformats-officedocument.spreadsheetml.printerSettings")
//                   || (typeString == "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml")
//                   || (typeString == "application/vnd.openxmlformats-officedocument.vmlDrawing")
//                   || (typeString == "application/vnd.openxmlformats-officedocument.drawing+xml")
//                   || (typeString == "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml")
//                   || (typeString == "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml")
//                   || (typeString == "image/x-emf")
//                   || (typeString == "image/png")
//                   || (typeString == "application/vnd.ms-excel.controlproperties+xml")
//                   || (typeString == "application/vnd.openxmlformats-officedocument.spreadsheetml.calcChain+xml")
//                   || (typeString == "application/vnd.openxmlformats-package.core-properties+xml")
//                   || (typeString == "application/vnd.openxmlformats-officedocument.custom-properties+xml")
//                   || (typeString == "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml")
//                   ||(partString =="xl/workbook.xml")
//                   ||(partString =="docProps/core.xml")
                   ||(partString =="xl/metadata.xml")
//                   ||(partString =="xl/sharedStrings.xml")
//                   ||(partString =="xl/theme/theme1.xml")
//                   ||(partString =="xl/styles.xml")
                   ||(partString =="xl/../customXml/item1.xml")
                   ||(partString =="xl/../customXml/item2.xml")
                   ||(partString =="xl/../customXml/item3.xml")
//                   ||(partString =="xl/worksheets/sheet1.xml")
//                   ||(partString =="customXml/item1.xml")
//                   ||(partString =="customXml/item2.xml")
//                   ||(partString =="customXml/item3.xml")
                   )
                {
                    continue;
                }

                opcContainerInputStream *instream = opcContainerOpenInputStream(source, part);
                
                if (instream != NULL) {
                    std::vector<unsigned char>buf(size);
                    if(opcContainerReadInputStream(instream, &buf[0], size) == size) {
                        part = opcPartCreate(target,
                                             part,
                                             type, 0);
                        opcContainerOutputStream *outstream = opcContainerCreateOutputStream(target,
                                                                                             part,
                                                                                             OPC_COMPRESSIONOPTION_NONE);
                        if(outstream != NULL) {
                            
                            if(size != 0) {
                                opcContainerWriteOutputStream(outstream,
                                                              &buf[0],
                                                              size);
                            }
                            
                            opcContainerCloseOutputStream(outstream);
                        }
                    }
                    opcContainerCloseInputStream(instream);
                    printf("copied part:%s;type:%s;\n\n",
                           part, type);
                }
                
            }
            opcContainerClose(target, OPC_CLOSE_TRIM);
        }
        opcContainerClose(source, OPC_CLOSE_NOW);
    }
    
}

#pragma mark MSOFFICE

static void Verify_office_document(PA_PluginParameters params) {
    
    PA_ObjectRef status = PA_CreateObject();
    ob_set_b(status, L"success", false);

    C_BLOB inXLSM;
    inXLSM.fromParamAtIndex(params, 1);

    const char *data = (const char *)inXLSM.getBytesPtr();
    const uint32_t dataSize = inXLSM.getBytesLength();
    
    ms::Format format;
    
    try {
        format = ms::DetectFormat(data, dataSize);
    } catch (std::exception& e) {
        format = ms::fUnknown;
    }
    
    switch (format) {
        case ms::fZip:
            ob_set_b(status, L"success", true);
            ob_set_a(status, L"format", L"Zip");
            break;
        case ms::fCfb:
            ob_set_b(status, L"success", true);
            ob_set_a(status, L"format", L"Cfb");
            break;
        default:
            ob_set_a(status, L"format", L"Unknown");
            break;
    }
    
    PA_ReturnObject(params, status);
}

static void Decode_office_document(PA_PluginParameters params) {
    
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    PA_ObjectRef status = PA_CreateObject();
    ob_set_b(status, L"success", false);
    
    C_BLOB inXLSM;
    inXLSM.fromParamAtIndex(params, 1);

    const char *data = (const char *)inXLSM.getBytesPtr();
    const uint32_t dataSize = inXLSM.getBytesLength();

    C_TEXT filepath;
    filepath.fromParamAtIndex(pParams, 2);

    CUTF8String filepath_u8;
    filepath.copyPath(&filepath_u8);
    
    C_TEXT password;
    password.fromParamAtIndex(pParams, 3);
    
    CUTF8String password_u8;
    password.copyUTF8String(&password_u8);

    const std::string outFile = (const char *)filepath_u8.c_str();
    
    cybozu::String16 wpass = cybozu::ToUtf16((const char *)password_u8.c_str());
    const std::string passData = ms::Char16toChar8(wpass);
    
    std::string secretKey;
    
    try {

        ob_set_b(status, L"success", ms::decode(data, dataSize,
                                                outFile, passData,
                                                secretKey, false));
    } catch (std::exception& e) {
       
    }
    
    PA_ReturnObject(params, status);
}

static void Encode_office_document(PA_PluginParameters params) {
 
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    PA_ObjectRef status = PA_CreateObject();
    ob_set_b(status, L"success", false);
    
    C_BLOB inXLSM;
    inXLSM.fromParamAtIndex(params, 1);

    const char *data = (const char *)inXLSM.getBytesPtr();
    const uint32_t dataSize = inXLSM.getBytesLength();

    C_TEXT filepath;
    filepath.fromParamAtIndex(pParams, 2);

    CUTF8String filepath_u8;
    filepath.copyPath(&filepath_u8);
    
    C_TEXT password;
    password.fromParamAtIndex(pParams, 3);
    
    CUTF8String password_u8;
    password.copyUTF8String(&password_u8);

    const std::string outFile = (const char *)filepath_u8.c_str();
    
    cybozu::String16 wpass = cybozu::ToUtf16((const char *)password_u8.c_str());
    const std::string passData = ms::Char16toChar8(wpass);
    
    std::string secretKey;
    
    encode_aes_t mode = (encode_aes_t)PA_GetLongParameter(params, 4);
    
    try {

        ob_set_b(status, L"success", ms::encode(data, dataSize,
                                                outFile, passData,
                                                mode, secretKey, false));
    } catch (std::exception& e) {
       
    }

    PA_ReturnObject(params, status);
}
